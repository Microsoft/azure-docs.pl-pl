---
title: Azure Service Bus komunikaty, ładunki i | Microsoft Docs
description: Ten artykuł zawiera omówienie komunikatów Azure Service Bus, ładunków, routingu komunikatów i serializacji.
ms.topic: article
ms.date: 04/14/2021
ms.openlocfilehash: 2ed65054f61aee4b9fb6157fc7a36e469c7a672c
ms.sourcegitcommit: db925ea0af071d2c81b7f0ae89464214f8167505
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 04/15/2021
ms.locfileid: "107515298"
---
# <a name="messages-payloads-and-serialization"></a>Komunikaty, ładunki i serializacja

Microsoft Azure Service Bus obsługuje komunikaty. Komunikaty zawierają ładunek i metadane. Metadane mają postać właściwości pary klucz-wartość i opisują ładunek oraz zawierają instrukcje obsługi dla Service Bus i aplikacji. Czasami same metadane wystarczają do przechowania informacji, które nadawca chce przekazać odbiorcom, a ładunek pozostaje pusty.

Model obiektów oficjalnych klientów sieci Service Bus dla platform .NET i Java odzwierciedla abstrakcyjną strukturę komunikatów Service Bus, która jest mapowana na protokoły przewodowe Service Bus i z nich.
 
Komunikat Service Bus składa się z binarnej sekcji ładunku, Service Bus nigdy nie obsługuje w żadnym formularzu po stronie usługi i dwóch zestawów właściwości. Właściwości *brokera* są wstępnie zdefiniowane przez system. Te wstępnie zdefiniowane właściwości kontrolują funkcje na poziomie komunikatów wewnątrz brokera lub są mapowane na typowe i standardowe elementy metadanych. Właściwości *użytkownika to* kolekcja par klucz-wartość, które mogą być definiowane i ustawiane przez aplikację.
 
W poniższej tabeli wymieniono wstępnie zdefiniowane właściwości brokera. Nazwy są używane ze wszystkimi oficjalnymi interfejsami API klienta, a także w obiekcie [JSON BrokerProperties](https://docs.microsoft.com/rest/api/servicebus/introduction) mapowania protokołu HTTP.
 
Równoważne nazwy używane na poziomie protokołu AMQP są wymienione w nawiasach. Podczas gdy poniższe nazwy używają wielkości obudowy Pascal, należy pamiętać, że klienci języków JavaScript i Python używają wielkościki camel i casing odpowiednio.

| Nazwa właściwości                         | Opis                                                                                                                                                                                                                                                                                                                                                                                                                               |
|---------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `ContentType` (typ zawartości)           | Opcjonalnie opisano ładunek komunikatu z deskryptorem w formacie RFC2045, sekcja 5; na przykład `application/json` .                                                                                                                                                                                                                                                                                             |
| `CorrelationId` (identyfikator korelacji)       | Umożliwia aplikacji określenie kontekstu komunikatu na potrzeby korelacji; na przykład odzwierciedlanie **messageid** komunikatu, na który jest odpowiedzi.                                                                                                                                                                                                                                                                  |
| `DeadLetterSource`                      | Ustawiane tylko w komunikatach, które zostały utracone i później automatycznie odwzajemniane z kolejki utraconych wiadomości do innej jednostki. Wskazuje jednostkę, w której komunikat został utracony. Ta właściwość jest tylko do odczytu.                                                                                                                                                                                                                                  |
| `DeliveryCount`                         | <p>Liczba dostaw, które podjęto próbę dla tego komunikatu. Liczba jest zwiększana, gdy blokada komunikatu wygaśnie lub komunikat jest jawnie porzucony przez odbiornik. Ta właściwość jest tylko do odczytu.</p> <p>Liczba dostaw nie jest zwiększana po zamknięciu bazowego połączenia AMQP.</p>                                                                                                                                                                                                                                                 |
| `EnqueuedSequenceNumber`                | W przypadku komunikatów, które zostały automatycznie odszukane, ta właściwość odzwierciedla numer sekwencji, który został wcześniej przypisany do komunikatu w jego oryginalnym punkcie przesyłania. Ta właściwość jest tylko do odczytu.                                                                                                                                                                                                                                                                |
| `EnqueuedTimeUtc`                       | Czas UTC, w którym komunikat został zaakceptowany i zapisany w jednostce. Ta wartość może służyć jako autorytatywny i neutralny wskaźnik czasu przylotu, gdy odbiorca nie chce ufać zegarowi nadawcy. Ta właściwość jest tylko do odczytu.                                                                                                                                                                                                   |
| `ExpiresAtUtc` (bezwzględny czas wygaśnięcia) | Czas UTC, w którym komunikat jest oznaczony do usunięcia i nie jest już dostępny do pobrania z jednostki z powodu jej wygaśnięcia. Właściwość Expiry jest kontrolowana przez **właściwość TimeToLive,** a ta właściwość jest obliczana z właściwości EnqueuedTimeUtc+TimeToLive. Ta właściwość jest tylko do odczytu.                                                                                                                                                                           |
| `Label` lub `Subject` (temat)                       | Ta właściwość umożliwia aplikacji wskazanie przeznaczenia wiadomości do odbiorcy w standardowy sposób, podobnie jak w wierszu tematu wiadomości e-mail.                                                                                                                                                                                                                                                                                  |
| `LockedUntilUtc`                        | W przypadku komunikatów pobieranych w ramach blokady (tryb odbierania podglądu blokady, bez wstępnej rozliczenia) ta właściwość odzwierciedla moment UTC, do którego komunikat jest blokowany w kolejce/subskrypcji. Po wygaśnięciu blokady wartość [DeliveryCount](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.deliverycount) jest zwiększana, a komunikat jest ponownie dostępny do pobrania. Ta właściwość jest tylko do odczytu.                                                                                                                         |
| `LockToken`                             | Token blokady to odwołanie do blokady przechowywanej przez brokera w *trybie odbierania za pomocą podglądu blokady.* Token może służyć do trwałego przypinania blokady za pośrednictwem interfejsu [API](message-deferral.md) odroczenia i w ten sposób wypływa komunikat ze zwykłego przepływu stanu dostarczania. Ta właściwość jest tylko do odczytu.                                                                                                                                                               |
| `MessageId` (identyfikator komunikatu)                | Identyfikator komunikatu jest wartością zdefiniowaną przez aplikację, która jednoznacznie identyfikuje komunikat i jego ładunek. Identyfikator jest ciągiem swobodnym i może odzwierciedlać identyfikator GUID lub identyfikator pochodzący z kontekstu aplikacji. Jeśli ta funkcja jest włączona, [funkcja](duplicate-detection.md) wykrywania duplikatów identyfikuje i usuwa drugie i dalsze przesyłanie komunikatów o tym samym **identyfikatorze MessageId.**                                                                |
| `PartitionKey`                          | W [przypadku jednostek podzielonych](service-bus-partitioning.md)na partycje ustawienie tej wartości umożliwia przypisywanie powiązanych komunikatów do tej samej partycji wewnętrznej, tak aby kolejność sekwencji przesyłania była poprawnie rejestrowana. Partycja jest wybierana przez funkcję skrótu dla tej wartości i nie można jej wybrać bezpośrednio. W przypadku jednostek z wiedzą o sesji właściwość **SessionId** zastępuje tę wartość.                                                                                                       |
| `ReplyTo` (odpowiedź na)                    | Ta opcjonalna i zdefiniowana przez aplikację wartość to standardowy sposób wyrażania ścieżki odpowiedzi do odbiorcy komunikatu. Gdy nadawca oczekuje odpowiedzi, ustawia wartość na ścieżkę bezwzględną lub względną kolejki lub tematu, do których oczekuje odpowiedzi.                                                                                                                                           |
| `ReplyToSessionId` (identyfikator odpowiedzi na grupę)  | Ta wartość rozszerza informacje **ReplyTo** i określa, który **identyfikator sesji** powinien być ustawiony dla odpowiedzi po wysłaniu do jednostki odpowiedzi.                                                                                                                                                                                                                                                                            |
| `ScheduledEnqueueTimeUtc`               | W przypadku komunikatów, które są dostępne do pobrania tylko po opóźnieniu, ta właściwość definiuje czas utc, o którym komunikat zostanie logicznie wyliowany, sekwencjonowany i w związku z tym będzie dostępny do pobrania.                                                                                                                                                                                                                 |
| `SequenceNumber`                        | Numer sekwencji to unikatowa 64-bitowa liczba całkowita przypisana do komunikatu, ponieważ jest akceptowana i przechowywana przez brokera oraz działa jako jej prawdziwy identyfikator. W przypadku jednostek podzielonych na partycje pierwsze 16 bitów odzwierciedla identyfikator partycji. Liczby sekwencji monotonicznie zwiększają się i są bez przerw. Przejmują one do wartości 0, gdy zakres 48–64-bitowy zostanie wyczerpany. Ta właściwość jest tylko do odczytu.                                                                |
| `SessionId` (group-id)                  | W przypadku jednostek z informacjami o sesji ta wartość zdefiniowana przez aplikację określa przynależność do sesji komunikatu. Komunikaty o tym samym identyfikatorze sesji podlegają blokowaniu podsumowania i umożliwiają dokładne przetwarzanie w porządek i zdezasekwowanie. W przypadku jednostek, które nie są świadome sesji, ta wartość jest ignorowana.                                                                                                                                     |
                                                                                                                                          |
| `TimeToLive`                            | Ta wartość to względny czas trwania, po którym komunikat wygasa, począwszy od chwili, gdy komunikat został zaakceptowany i zapisany przez brokera, zgodnie z informacjami w **enqueueTimeUtc**. Jeśli nie ustawiono jawnie, założona wartość to **DefaultTimeToLive** dla odpowiedniej kolejki lub tematu. Wartość **TimeToLive na** poziomie komunikatu nie może być dłuższa niż ustawienie **DefaultTimeToLive** jednostki. Jeśli jest dłuższy, jest on dostosowywany w trybie dyskretnym. |
| `To` (do)                               | Ta właściwość jest zarezerwowana do użytku w przyszłości w scenariuszach routingu i obecnie ignorowana przez samego brokera. Aplikacje mogą używać tej wartości w scenariuszach automatycznego łańcucha wewnętrznego opartych na regułach, aby wskazać zamierzony logiczny cel komunikatu.                                                                                                                                                                                   |
| `ViaPartitionKey`                       | Jeśli komunikat jest wysyłany za pośrednictwem kolejki transferu w zakresie transakcji, ta wartość wybiera partycję kolejki transferu.                                                                                                                                                                                                                                                                                                                 |

Model abstrakcyjnych komunikatów umożliwia przesłanie komunikatu do kolejki za pośrednictwem protokołu HTTPS i pobranie go za pośrednictwem protokołu AMQP. W obu przypadkach komunikat wygląda normalnie w kontekście odpowiedniego protokołu. Właściwości brokera są tłumaczone zgodnie z potrzebami, a właściwości użytkownika są mapowane na najbardziej odpowiednią lokalizację w odpowiednim modelu komunikatów protokołu. W przypadku protokołu HTTP właściwości użytkownika są mapowanie bezpośrednio do nagłówków HTTP i z nagłówków HTTP; W przypadku usługi AMQP mapują do i z **mapy właściwości** aplikacji.

## <a name="message-routing-and-correlation"></a>Routing i korelacja komunikatów

Podzbiór opisanych wcześniej właściwości brokera, w szczególności , , , , i , jest używany do pomocy aplikacjom w rozsyłania `To` `ReplyTo` `ReplyToSessionId` `MessageId` `CorrelationId` `SessionId` komunikatów do określonych miejsc docelowych. Aby zilustrować tę funkcję, należy wziąć pod uwagę kilka wzorców:

- **Proste żądanie/odpowiedź:** wydawca wysyła komunikat do kolejki i oczekuje odpowiedzi od konsumenta komunikatów. Aby otrzymać odpowiedź, wydawca jest właścicielem kolejki, do której oczekuje dostarczenia odpowiedzi. Adres tej kolejki jest wyrażony we właściwości **ReplyTo** komunikatu wychodzącego. Gdy konsument odpowie, kopiuje identyfikator **MessageId** obsługiwanego komunikatu do właściwości **CorrelationId** komunikatu odpowiedzi i dostarcza komunikat do miejsca docelowego wskazanego przez właściwość **ReplyTo.** Jeden komunikat może uzyskać wiele odpowiedzi, w zależności od kontekstu aplikacji.
- **Żądanie/odpowiedź** multiemisji: jako odmiana poprzedniego wzorca wydawca wysyła komunikat do tematu, a wielu subskrybentów kwalifikuje się do korzystania z komunikatu. Każdy z subskrybentów może odpowiedzieć w opisany wcześniej sposób. Ten wzorzec jest używany w scenariuszach odnajdywania lub rzutowania, a respondent zazwyczaj identyfikuje się za pomocą właściwości użytkownika lub wewnątrz ładunku. Jeśli **funkcja ReplyTo** wskazuje temat, taki zestaw odpowiedzi odnajdywania może być dystrybuowany do odbiorców.
- **Multipleksowanie:** ta funkcja sesji umożliwia multipleksowanie strumieni powiązanych komunikatów za pośrednictwem jednej kolejki lub subskrypcji w taki sposób, że każda sesja (lub grupa) powiązanych komunikatów, identyfikowanych przez zgodne wartości **SessionId,** jest przekierowyowana do określonego odbiornika, podczas gdy odbiornik utrzymuje sesję pod blokadą. Więcej informacji o sesjach można znaleźć [tutaj.](message-sessions.md)
- **Multipleksowane żądanie/odpowiedź:** ta funkcja sesji umożliwia multipleksowanie odpowiedzi, umożliwiając kilku wydawcom współużytkowanie kolejki odpowiedzi. Ustawiając **wartość ReplyToSessionId,** wydawca może poinstruować odbiorców, aby skopiowali tę wartość do właściwości **SessionId** komunikatu odpowiedzi. Kolejka publikowania lub temat nie muszą być zdawać sobie sprawę z sesji. Po wysłaniu komunikatu wydawca może czekać na sesję z danym **sessionId,** aby zmaterializować w kolejce, warunkowo akceptując odbiornik sesji. 

Routing wewnątrz przestrzeni nazw Service Bus można zrealizować przy użyciu automatycznego łańcucha wewnętrznego i reguł subskrypcji tematu. Routing między przestrzeniami nazw można zrealizować przy [użyciu usługi Azure LogicApps.](https://azure.microsoft.com/services/logic-apps/) Jak wskazano na poprzedniej liście, właściwość **To** jest zarezerwowana do użytku w przyszłości i może zostać ostatecznie zinterpretowana przez brokera za pomocą specjalnie włączonej funkcji. Aplikacje, które chcą zaimplementować routing, powinny to robić na podstawie właściwości użytkownika i nie powinny opierać się na właściwości **Do;** Jednak to teraz nie spowoduje problemów ze zgodnością.

## <a name="payload-serialization"></a>Serializacja ładunku

Podczas przesyłania lub przechowywania wewnątrz Service Bus ładunkiem jest zawsze nieprzezroczysty, binarny blok. Właściwość umożliwia aplikacjom opisywanie ładunku przy sugerowanym formacie wartości właściwości jako opisie typu zawartości MIME zgodnie z dokumencie `ContentType` IETF RFC2045, na przykład `application/json;charset=utf-8` .

W przeciwieństwie do wariantów języka Java lub .NET Standard Service Bus wersja interfejsu API .NET Framework obsługuje tworzenie wystąpień **BrokeredMessage** przez przekazywanie dowolnych obiektów .NET do konstruktora. 

W przypadku korzystania ze starszej wersji protokołu SBMP te obiekty są następnie serializowane przy użyciu domyślnego serializatora binarnego lub serializatora dostarczonego zewnętrznie. W przypadku korzystania z protokołu AMQP obiekt jest serializowany do obiektu AMQP. Odbiornik może pobrać te obiekty za pomocą [metody GetBody \<T> (),](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.getbody#Microsoft_ServiceBus_Messaging_BrokeredMessage_GetBody__1) dostarczając oczekiwany typ. W przypadku usługi AMQP obiekty są serializowane do grafu AMQP obiektów i , a każdy klient `ArrayList` `IDictionary<string,object>` AMQP może je zdekodować. 

Ta ukryta magia serializacji jest wygodna, ale aplikacje powinny jawnie kontrolować serializację obiektów i przekształcić ich wykresy obiektów w strumienie przed ich włączeniem w komunikat i wykonać odwrotną transmisję po stronie odbiornika. Daje to wyniki współdziałania. Protokół AMQP ma zaawansowany model kodowania binarnego, ale jest powiązany z ekosystemem obsługi komunikatów PROTOKOŁU AMQP, a klienci HTTP będą mieć problemy z dekodowaniem takich ładunków. 

Warianty .NET Standard api języka Java akceptują tylko tablice bajtów, co oznacza, że aplikacja musi obsługiwać kontrolkę serializacji obiektów. 

## <a name="next-steps"></a>Następne kroki

Aby dowiedzieć się więcej na Service Bus wiadomości, zobacz następujące tematy:

* [Kolejki, tematy i subskrypcje usługi Service Bus](service-bus-queues-topics-subscriptions.md)
* [Wprowadzenie do kolejek usługi Service Bus](service-bus-dotnet-get-started-with-queues.md)
* [Jak używać tematów i subskrypcji usługi Service Bus](service-bus-dotnet-how-to-use-topics-subscriptions.md)
